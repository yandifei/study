# f-string 自文档化表达
print(f"{5+2= }")




"""
刮刮乐的玩法多种多样，彩民只要刮去刮刮乐上的银色油墨后即可查看是否中奖。
假设现在有一张刮刮乐，该卡片上面共有8个刮奖区，
每个刮奖区对应的兑奖信息依次为"谢谢惠顾"、"一等奖"、"三等奖"、"谢谢惠顾"、"谢谢惠顾"、 "三等奖"、"二等奖"、"谢谢惠顾"，
只能刮开其中一个区域。本实例要求编写程序，实现根据用户输入的刮奖区序号展示兑奖信息的过程。
"""

"""
# 用字面量去加快
list1 = ["谢谢惠顾","一等奖","三等奖","谢谢惠顾","谢谢惠顾", "三等奖","二等奖","谢谢惠顾"]
# 用户输入1-8的数字判断是否是有该区域
if 1 <= (num := int(input("请输入你要刮的区域（1-8）:"))) <= 8:
    print(list1[num - 1])
else:
    print("没有改区域")
"""

# 列表拼接
list2 = [1 ,2 , 3] + [4, 5, 6, 7]
print(f"列表拼接:{list2}，除了append还能用+") # 得做个性能测试（append是添加单个元素的，+可以直接+列表，但是不知道性能如何）
print("append(): 原地操作，直接在列表末尾添加元素 + 操作符: 创建新列表，复制所有元素，效率极低")

# 列表自身进行 n 次拼接
list2 = [1 ,2 , 3] * 3
print(list2)

# 切片(0开始，但是不会到2)
print([1 ,2 , 3, 4, 5, 6, 7][0:2])

# del关键字
list3 = [1 ,2 , 3, 4, 5, 6, 7]
del list3[0:2]
print(f"del后{list3}")

# 切片元素替换(s[i:j:k] = t 将 s[i:j:k] 的元素替换为 t 的元素)
list3 = [1, 2, 3, 4, 5, 6, 7]
list3[0:5:2] = [10, 20, 30]  # 替换的必须是以列表的形式（好鸡肋，必须切片必须指定替换的列表）
print(f"切片替换{list3}")

# 排序
list4 = [9 , 1, 7, 2, 3]
list4.sort()
print(list4)

# 字符串的长度排序
list5 = ["abc", "a", "ab", "abcde", "b"]
list5.sort(key=len)
print(list5)


# 列表清理性能
print("s.clear() 或 del s 或 s = None 或 s = list() 或 s = []哪种更快？ 还得是官方的s.clear()")

# 深拷贝和潜拷贝
list6 = list5.copy()
print(list6)