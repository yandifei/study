### 1. 初始化流程
1. 判断聊天窗口是否存在，检验聊天窗口是否真实
2. 遍历根窗口的子窗口的Name是否存在给定聊天窗口的QQ群名或QQ好友名，在此窗口上深度遍历找到群QQ群名或QQ好友名二次确认是否符合要求(通过控件结构确保绑定的聊天窗口不是别的窗口)
3. 获取聊天窗口的各个控件对象、包括属性、方便以后直接对窗口进行操作而不用再次遍历

问题处理:
1. 多个QQ对同一个群或同一个好友进行监听时该如何处理被监听者名字相同的问题(我只提供群聊名称的输入，简化流程给用户)。利用同一个QQ窗口的进程ID一致判断不同QQ监听
2. 窗口句柄判断不同的窗口、窗口进程判断窗口属于哪个QQ
3. 后台能找到窗口和进程但是少了关键的文档

如果创建的是QQMessageMonitor这个对象就自动创建qq群聊或qq好友的对象，自动完成向上转型的操作

发现有2相同名字的窗口直接报错，如果要强制绑定就改名或提供句柄

可以通过类名和标题区分QQ聊天窗口和QQ本体

语音通话我没给权限提示我给权限，有这个窗口存在，后续封装得注意
语音按钮按钮也是

如果点击了群搜索后点击qq窗口以外的控件再次使用搜索控件就会发生溢出

好友聊天窗口和群聊的标题栏(title_bar)即窗口控制按钮一致

群聊窗口比好友窗口少了公告栏、群成员框

编辑工具栏如果是q群有可能少一个控件，qq机器人指令这个控件

在包目录下创建一个文件夹，文件夹用监听者的名字取名（但是目录不能存在特殊字符，如果超过一定字符或许有win自生bug蓝屏）
这个文件夹会创建一个以监听窗口（需要对特殊字符进行改变）\ / : * ? " < > |

公告会有所不同，有的群没有公告
如果公告里有图片解析方式又会不同了
1.群公告没有2.群公告要填写3.群公告有图片4.群公告有链接
公告只能是图片和文本（文本的链接可以被解析）
三层遍历
```python
def bulletin_split(obj):
    """公告文本解析（2层）可以判断该是否有公告消息，但是必须存在公告这个控件（群主可以不写公告但会有这个框）
    参数:obj:公告对象
    """
    # 无、1层、2层（链接）
    bulletin_message = ""   # 信息存储
    if len(obj.GetChildren()) != 0:
        for i in obj.GetChildren():
            if len(i.GetChildren()) != 0:   # 存在子控件需要深度查找
                for j in i.GetChildren():
                    if j.LocalizedControlType == "文本":
                        bulletin_message += j.Name + " " # 添加文本
            elif i.LocalizedControlType == "文本":    # 没有子控件
                bulletin_message += i.Name + " " # 添加文本
    return bulletin_message
```

# 消息监控
考虑到内存十分宝贵，如果消息够多对内存占用就太大了
列表的形式记录消息条数，元素是字符串或对象
qq的消息本质上可以分为2种，文本为主体、文件(图片、pdf、程序等非文本)。一条消息列表可由文本就和文件复合构成
## 1. ***分布式考虑***
单个账号对多个窗口进行监听
多个账号对单个窗口进行监听
多账号对多窗口进行监听
如果还是把消息放在内存那就完了，内存压力一定会很大
这里我就采用程序局部性原理(正态分布)
1. 空间局部性:把当前能监测到的数据放入内存，因为是当前必须用到的，即为当前能监听到的消息或需要进行处理反馈的消息，如设置的指令消息
2. 时间局部性:当前消息一般都是活跃消息，对活跃或必要性消息进行监控(有人@我或我指定某种消息为必要监听消息)。
3. 如果每监测到新的消息就写入txt会导致cpu调度繁忙，监听多个窗口会加大cpu的压力。缺点是txt不能立即实时记录最新的消息，如果突然断电会导致记录有较大的缺失

原理简说：消息记录保存类似于word，写好后一定记得保存，不然下次打开就白写。消息记录保存就是每隔一小段时间或达到相应条件就会保存一次，这就更写论文怕断电白写每隔一段时间ctrl+s保存一样，因为你不能每写一个字就保存一下，那不累死了。

***最终方案***
1. 默认消息监测到一定程度才一次性写入并在内存进行销毁（存在缓存区）。
2. 读取到有新的消息就写入

可以传入参数选择实时写入还是默认的方式写入

## 消息分割
可以通过`AutomationId`区分是不是同一个控件，判断是不是同一个控件，用来判断消息是不是更新了，在消息列表的组里面撤回的消息后不会影响`AutomationId`属性的改变

消息组合体3个组大多数为文件

时间会嵌入一个消息控件里面

最新的消息是在最后一个控件里面也就是最后的一个下表里面

自己收藏的表情无论是动态还是ss静态都被列为`"图片"图像`

对比获得的消息列表，排除没有用重复的消息，控件ID监测

消息结构:  时间 发送者 消息体

调用一次消息监听函数就更新属性
```python
self.messages_count = None  # 记录消息数属性(调用消息监控会更新)
self.AutomationId_list = None   # 记录获得消息控件的所有ID(调用消息监控会更新)
self.message_list = None  # 设置一个列表接收消息
```

致命缺点就是不能精准记录qq消息发送的时间,只能记录监控的时间。初次监控后消息会结合当前程序的时间被录入列表里面但是并不能代表这个结合的时间就是qq原来真实的时间
比如：一条消息是早上9：00发的，但是监测是按当前时间记录的，也就是只有在监控过程中时间才是精准的(约等于qq消息发送的时间)，初次调用截获消息的时间记录可能无效(最高有17条消息记录的时间无效)
后续优化可以处理`pass`



## 文件监听
**QQ给的可选的保存位置**
将接收的文件保存到:`B:\QQ聊天文件资料\Tencent`
聊天消息默认保存到:`B:\QQ聊天文件资料\聊天文件`
**文件分析**
目录:`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Thumb`
在这个目录下会记录聊天信息中产生的图片缩略图，如果是多窗口所有图片缩略图都是汇总到这个目录下，即使把这个目录的说有图片缩略图删除了，只要回到相应的聊天窗口也能恢复图片缩略图。猜测聊天中对方发送的图片缩略图信息是保存在服务器中，我这里本地删除后回到对应的聊天记录又会加载保存到这个目录下。
***如果是别人发送的图片会产生2个图片，一个是略所图，一个是原图。如果我在qq中加载后会把原图放到Ori目录下***
目录:`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Ori`
这个是没经过压缩的原始图片文件路径，自己发送的图片或自己手动点开别人的图片加载后都会保存到这里
如果是自己发送的图片会在`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Ori`和`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Thumb`保存，Ori目录保存的是原文件（日期时间都没有改），Thumb保存的是压缩后的图片
表情包存放目录:`默认保存位置\qq账号\nt_qq\nt_data\Emoji\emoji-recv\当前年份和月份\Ori`
表情包压缩存放目录:`默认保存位置\qq账号\nt_qq\nt_data\Emoji\emoji-recv\当前年份和月份\Thumb`



数据形式
文本
图片
链接（不是文本展示的链接）
gif收藏表情
png收藏表情
qq自带动态表情
png图片文件
pdf文件
ppt文件
txt文件
MP4视频文件




**数据获取合法性**
脚本是通过读取控件元素获取文本消息的，图片消息是查看本地磁盘目录的，并未存在破解数据库、抓包破解的相关操作。事实上web层面上数据读取和数据操作速度更快也更好，但是qq没有提供api给编程者，只有QQ Bot的API（这也使得不能一个exe即可布置好QQ Bot）。
