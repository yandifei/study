### 1. 初始化流程
1. 判断聊天窗口是否存在，检验聊天窗口是否真实
2. 遍历根窗口的子窗口的Name是否存在给定聊天窗口的QQ群名或QQ好友名，在此窗口上深度遍历找到群QQ群名或QQ好友名二次确认是否符合要求(通过控件结构确保绑定的聊天窗口不是别的窗口)
3. 获取聊天窗口的各个控件对象、包括属性、方便以后直接对窗口进行操作而不用再次遍历

问题处理:
1. 多个QQ对同一个群或同一个好友进行监听时该如何处理被监听者名字相同的问题(我只提供群聊名称的输入，简化流程给用户)。利用同一个QQ窗口的进程ID一致判断不同QQ监听
2. 窗口句柄判断不同的窗口、窗口进程判断窗口属于哪个QQ
3. 后台能找到窗口和进程但是少了关键的文档

如果创建的是QQMessageMonitor这个对象就自动创建qq群聊或qq好友的对象，自动完成向上转型的操作

发现有2相同名字的窗口直接报错，如果要强制绑定就改名或提供句柄

可以通过类名和标题区分QQ聊天窗口和QQ本体

语音通话我没给权限提示我给权限，有这个窗口存在，后续封装得注意
语音按钮按钮也是

如果点击了群搜索后点击qq窗口以外的控件再次使用搜索控件就会发生溢出

好友聊天窗口和群聊的标题栏(title_bar)即窗口控制按钮一致

群聊窗口比好友窗口少了公告栏、群成员框

编辑工具栏如果是q群有可能少一个控件，qq机器人指令这个控件

在包目录下创建一个文件夹，文件夹用监听者的名字取名（但是目录不能存在特殊字符，如果超过一定字符或许有win自生bug蓝屏）
这个文件夹会创建一个以监听窗口（需要对特殊字符进行改变）\ / : * ? " < > |

公告会有所不同，有的群没有公告
如果公告里有图片解析方式又会不同了
1.群公告没有2.群公告要填写3.群公告有图片4.群公告有链接
公告只能是图片和文本（文本的链接可以被解析）
三层遍历
```python
def bulletin_split(obj):
    """公告文本解析（2层）可以判断该是否有公告消息，但是必须存在公告这个控件（群主可以不写公告但会有这个框）
    参数:obj:公告对象
    """
    # 无、1层、2层（链接）
    bulletin_message = ""   # 信息存储
    if len(obj.GetChildren()) != 0:
        for i in obj.GetChildren():
            if len(i.GetChildren()) != 0:   # 存在子控件需要深度查找
                for j in i.GetChildren():
                    if j.LocalizedControlType == "文本":
                        bulletin_message += j.Name + " " # 添加文本
            elif i.LocalizedControlType == "文本":    # 没有子控件
                bulletin_message += i.Name + " " # 添加文本
    return bulletin_message
```

# 消息监控
考虑到内存十分宝贵，如果消息够多对内存占用就太大了
列表的形式记录消息条数，元素是字符串或对象
qq的消息本质上可以分为2种，文本为主体、文件(图片、pdf、程序等非文本)。一条消息列表可由文本就和文件复合构成
## 1. ***分布式考虑***
单个账号对多个窗口进行监听
多个账号对单个窗口进行监听
多账号对多窗口进行监听
如果还是把消息放在内存那就完了，内存压力一定会很大
这里我就采用程序局部性原理(正态分布)
1. 空间局部性:把当前能监测到的数据放入内存，因为是当前必须用到的，即为当前能监听到的消息或需要进行处理反馈的消息，如设置的指令消息
2. 时间局部性:当前消息一般都是活跃消息，对活跃或必要性消息进行监控(有人@我或我指定某种消息为必要监听消息)。
3. 如果每监测到新的消息就写入txt会导致cpu调度繁忙，监听多个窗口会加大cpu的压力。缺点是txt不能立即实时记录最新的消息，如果突然断电会导致记录有较大的缺失

原理简说：消息记录保存类似于word，写好后一定记得保存，不然下次打开就白写。消息记录保存就是每隔一小段时间或达到相应条件就会保存一次，这就更写论文怕断电白写每隔一段时间ctrl+s保存一样，因为你不能每写一个字就保存一下，那不累死了。

***最终方案***
1. 默认消息监测到一定程度才一次性写入并在内存进行销毁（存在缓存区）。
2. 读取到有新的消息就写入

可以传入参数选择实时写入还是默认的方式写入

## 消息分割
可以通过`AutomationId`区分是不是同一个控件，判断是不是同一个控件，用来判断消息是不是更新了，在消息列表的组里面撤回的消息后不会影响`AutomationId`属性的改变

消息组合体3个组大多数为文件

时间会嵌入一个消息控件里面

最新的消息是在最后一个控件里面也就是最后的一个下表里面

自己收藏的表情无论是动态还是ss静态都被列为`"图片"图像`

对比获得的消息列表，排除没有用重复的消息，控件ID监测

消息结构:  时间 发送者 消息体

调用一次消息监听函数就更新属性
```python
self.messages_count = None  # 记录消息数属性(调用消息监控会更新)
self.AutomationId_list = None   # 记录获得消息控件的所有ID(调用消息监控会更新)
self.message_list = None  # 设置一个列表接收消息
```

致命缺点就是不能精准记录qq消息发送的时间,只能记录监控的时间。初次监控后消息会结合当前程序的时间被录入列表里面但是并不能代表这个结合的时间就是qq原来真实的时间
比如：一条消息是早上9：00发的，但是监测是按当前时间记录的，也就是只有在监控过程中时间才是精准的(约等于qq消息发送的时间)，初次调用截获消息的时间记录可能无效(最高有17条消息记录的时间无效)
后续优化可以处理`pass`

如果没有任何消息，那消息列表是否还存在控件，初始化的时候是否会造成下表溢出导致程序终止？

最开始的思路是节约时间和空间复杂度，只对新的消息进行遍历，不对部分旧的消息也进行遍历。
少了遍历的次数，时间节约了，列表也不用放入其他消息体节约空间

存在未知bug，消息体无法清空
## 文件监听
**QQ给的可选的保存位置**
将接收的文件保存到:`B:\QQ聊天文件资料\Tencent`
聊天消息默认保存到:`B:\QQ聊天文件资料\聊天文件`
**文件分析**
目录:`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Thumb`
在这个目录下会记录聊天信息中产生的图片缩略图，如果是多窗口所有图片缩略图都是汇总到这个目录下，即使把这个目录的说有图片缩略图删除了，只要回到相应的聊天窗口也能恢复图片缩略图。猜测聊天中对方发送的图片缩略图信息是保存在服务器中，我这里本地删除后回到对应的聊天记录又会加载保存到这个目录下。
***如果是别人发送的图片会产生2个图片，一个是略所图，一个是原图。如果我在qq中加载后会把原图放到Ori目录下***
目录:`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Ori`
这个是没经过压缩的原始图片文件路径，自己发送的图片或自己手动点开别人的图片加载后都会保存到这里
如果是自己发送的图片会在`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Ori`和`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Thumb`保存，Ori目录保存的是原文件（日期时间都没有改），Thumb保存的是压缩后的图片
表情包存放目录:`默认保存位置\qq账号\nt_qq\nt_data\Emoji\emoji-recv\当前年份和月份\Ori`
表情包压缩存放目录:`默认保存位置\qq账号\nt_qq\nt_data\Emoji\emoji-recv\当前年份和月份\Thumb`



数据形式
文本
图片
链接（不是文本展示的链接）
gif收藏表情
png收藏表情
qq自带动态表情
png图片文件
pdf文件
ppt文件
txt文件
MP4视频文件




**数据获取合法性**
脚本是通过读取控件元素获取文本消息的，图片消息是查看本地磁盘目录的，并未存在破解数据库、抓包破解的相关操作。事实上web层面上数据读取和数据操作速度更快也更好，但是qq没有提供api给编程者，只有QQ Bot的API（这也使得不能一个exe即可布置好QQ Bot）。


## BUG
```python
message_child = self.message_list_box.GetChildren()  # 这里多一个变量是为了2次遍历相同的控件
        for message_control in message_child    :# 优先遍历控件id动态更改属性
            self.AutomationId_list.append(message_control.AutomationId)  # 放置控件id
        for message_control in message_child:   # 以下标的形式遍历(方便后续处理)
            try:
                message_control = message_control.GetChildren()[0]  # 进入组控件里面（所有都单个消息控件都得进入）
                pass  # IndexError: list index out of range  提示我下标溢出
            except():
                print(len(message_control.GetChildren()))   # 打控件的子孩子数
                raise ValueError("这里会提示下标溢出，可能没有监测到控件")
```
下标溢出但是不知道为什么，亲手触发了一次，但是第二次无法触发了


# 全部可调用的属性
```python
self.win_name = str(win_name)    # 左上角窗口名字(如果有备注名就填备注名) 强制转为字符串
self.monitor_name = str(monitor_name)   # 强制转为字符串
self.parameter_validation() # 调用函数对参数进行校验
# 窗口初始化相关
self.group_or_friend = None # 记录窗口QQ群还是好友
self.qq_chat_win = self.find_qq_chat_win(self.top_window_traversal())   # 遍历顶层窗口->从顶层窗口中找到指定的qq聊天窗口
self.qq_chat_hwnd = self.qq_chat_win.NativeWindowHandle # 被监听窗口的句柄
self.cancel_top_win()   # 取消窗口置顶，防止窗口置顶失效
self.top_win()  # 把窗口置顶，防止窗口被遮挡导致渲染停止无法监控窗口
self.top_wait_time = 1  # 设置置顶后等待qq渲染完成的属性，（如果电脑卡的话可以调大属性）
sleep(self.top_wait_time)    # 等待1秒窗口完全置顶（qq置顶后渲染需要时间）
self.pid = self.qq_chat_win.ProcessId   # 被监听窗口的进程ID
self.geometry = self.qq_chat_win.BoundingRectangle  # 窗口的位置和大小
print(f"成功绑定“{win_name}”{self.jude_group_or_friend(self.qq_chat_win)}窗口并置顶窗口\t监听者：{monitor_name}")# 把对象进行绑定，动态属性修改并打印
print(f"“{win_name}”句柄:{self.qq_chat_hwnd}\t进程ID:{self.pid}\t窗口大小:{self.geometry}")
"""------------------------------------------聊天窗口控制监控相关---------------------------------------------"""
# 文档->组->组2(子孩子有2个组，第一个组是窗口控制按钮相关，第二个组是非窗口控制按钮的界面)
self.main_chat_win = self.qq_chat_win.GetChildren()[0].GetChildren()[0].GetChildren()[1]
# 文档->组->组2->组2(好友有2个组，群有3个组)可以用来区分qq还是群
"""标题栏(title_bar)[窗口控制按钮]"""
self.top_button = self.main_chat_win.GetChildren()[0].GetChildren()[0]  #置顶（复合按钮）按钮
self.min_button = self.main_chat_win.GetChildren()[0].GetChildren()[1]  # 最小化按钮
self.max_button = self.main_chat_win.GetChildren()[0].GetChildren()[2]  # 最大化按钮
self.close_button = self.main_chat_win.GetChildren()[0].GetChildren()[3]    # 关闭按钮
"""菜单栏(menu_bar)[菜单标题(好友名或群名和人数)、菜单选项按钮]"""
# 2个组里面->组2->组1->组2->左上菜单栏->有2个组（1个是群名，一个是人数）
self.menu_bar = self.main_chat_win.GetChildren()[1].GetChildren()[0].GetChildren()[1]    # 标题栏左边
if self.group_or_friend == "群聊":
    self.menu_bar_button = self.menu_bar.GetChildren()[0] # 群按钮（群名或备注名和人数）
    self.menu_bar_group_name = self.menu_bar_button.GetChildren()[0] # 群名(群按钮子的第一个子孩子)
    self.menu_bar_group_count = self.menu_bar_button.GetChildren()[1] # 群人数(群按钮子的第二个子孩子)
elif self.group_or_friend == "好友":
    self.menu_bar_button = self.menu_bar.GetChildren()[0]  # 好友按钮(好友名或备注名)
# 2个组里面->组2->组1->组3->"更多"工具栏->6个组都菜单栏选项按钮（6个组里面对应语音通话、视频通话、屏幕共享、群应用、邀请加群、展开菜单的按钮）
self.menu_option_buttons  =self.main_chat_win.GetChildren()[1].GetChildren()[0].GetChildren()[2].GetChildren()[0]
self.voice_call_button = self.menu_option_buttons.GetChildren()[0].GetChildren()[0] # 语音通话
self.video_call_button = self.menu_option_buttons.GetChildren()[1].GetChildren()[0] # 视频通话
self.screen_share_toggle = self.menu_option_buttons.GetChildren()[2].GetChildren()[0] # 屏幕共享
if self.group_or_friend == "群聊":
    self.group_application = self.menu_option_buttons.GetChildren()[3].GetChildren()[0] # 群应用
    self.invite_to_group_button = self.menu_option_buttons.GetChildren()[4].GetChildren()[0] # 邀请加群
elif self.group_or_friend == "好友":
    self.remote_control = self.menu_option_buttons.GetChildren()[3].GetChildren()[0] # 远程协助
    self.group_building = self.menu_option_buttons.GetChildren()[4].GetChildren()[0]  # 发起群聊
self.more_button = self.menu_option_buttons.GetChildren()[5].GetChildren()[0]  # 展开菜单的按钮
"""消息列表框(message_list_box)"""
# 2个组里面->组2->组2->组1->组3->组0->组0->全是消息控件，需要解析
self.message_list_box = self.main_chat_win.GetChildren()[1].GetChildren()[1].GetChildren()[0].GetChildren()[2].GetChildren()[0].GetChildren()[0]
self.messages_count = 0  # 记录最大消息数(调用消息监控会更新)
self.AutomationId_list = list()   # 记录获得消息控件的所有ID(调用消息监控会更新)
self.message_list = list()  # 设置一个列表接收消息
self.get_messages() # 创建对象的时候就对窗口进行一次监听，并把记录保存下来(动态属性修改)
self.control_id_index = 0  # 旧表的最后一个控件id下标，用来定位新表(默认新表的第一个控件遍历消息体)
"""编辑工具栏(edit_tool_bar)"""
# 2个组里面->组2->组2->组2->组3->7个组(表情、截图、文件、图片、红包、语音、聊天记录)
self.edit_tool_bar = self.main_chat_win.GetChildren()[1].GetChildren()[1].GetChildren()[1].GetChildren()[2]
self.expression_button = self.edit_tool_bar.GetChildren()[0].GetChildren()[0]   # 表情按钮
self.screenshot_button = self.edit_tool_bar.GetChildren()[1].GetChildren()[0]   # 截图按钮
self.screenshot_arrow = self.edit_tool_bar.GetChildren()[1].GetChildren()[1].GetChildren()[0] # 截图 Alt + S弹出菜单
self.folder_button = self.edit_tool_bar.GetChildren()[2].GetChildren()[0]   # 文件按钮
self.folder_arrow_button2 = self.edit_tool_bar.GetChildren()[2].GetChildren()[1].GetChildren()[0]  # 文件弹出菜单
self.image_button = self.edit_tool_bar.GetChildren()[3].GetChildren()[0]   # 图片按钮
if self.group_or_friend == "群聊":
    self.lucky_money_button = self.edit_tool_bar.GetChildren()[4].GetChildren()[0]   # 红包按钮
    self.microphone_on_button = self.edit_tool_bar.GetChildren()[5].GetChildren()[0]   # 语音按钮
elif self.group_or_friend == "好友":
    self.shake_button = self.edit_tool_bar.GetChildren()[4].GetChildren()[0]   # 窗口抖动按钮
    self.lucky_money_button = self.edit_tool_bar.GetChildren()[5].GetChildren()[0]   # 红包按钮
    self.microphone_on_button = self.edit_tool_bar.GetChildren()[6].GetChildren()[0]   # 语音按钮
if self.edit_tool_bar.GetChildren()[6].GetChildren()[0] == "机器人指令":  # qq群和好友不会起冲突(qq群这里可能少一个按钮)
    self.message_record_button = self.edit_tool_bar.GetChildren()[7].GetChildren()[0]   # 聊天记录按钮
elif self.edit_tool_bar.GetChildren()[6].GetChildren()[0] == "聊天记录":    # 少了机器人指令按钮
    self.message_record_button = self.edit_tool_bar.GetChildren()[6].GetChildren()[0]  # 聊天记录按钮
"""编辑框(edit_box)[textbox、关闭按钮、发送按钮]"""
# 2个组里面->组2->组2->组2->组4->组->组1("编辑"EditControl)[这个下面还有一个TextControl"文本"的子控件]
self.edit_box = self.main_chat_win.GetChildren()[1].GetChildren()[1].GetChildren()[1].GetChildren()[3].GetChildren()[0].GetChildren()[1]
# 2个组里面->组2->组2->组2->组5->组1(关闭按钮)
self.edit_box_close_button =  self.main_chat_win.GetChildren()[1].GetChildren()[1].GetChildren()[1].GetChildren()[4].GetChildren()[0]
# 2个组里面->组2->组2->组2->组5->组2->组1(发送按钮)
self.enter_button = self.main_chat_win.GetChildren()[1].GetChildren()[1].GetChildren()[1].GetChildren()[4].GetChildren()[1].GetChildren()[0]
"""公告栏(bulletin_bar)[群公告文本控件、群公告按钮、可见的群公告文本]"""
if self.group_or_friend == "群聊" and len(self.main_chat_win.GetChildren()[1].GetChildren()[2].GetChildren()[0].GetChildren()) == 5:  # 如果等于4就代表没有公告，5才有公告
    # 2个组里面->组3->组1->组1->组1(有3个子孩子[群公告文本、群公告按钮、可见的群公告文本])
    self.bulletin_bar = self.main_chat_win.GetChildren()[1].GetChildren()[2].GetChildren()[0].GetChildren()[0]
    # self.bulletin_text_button = self.bulletin_bar.GetChildren()[0].GetChildren()[0] # 群公告文字（节约空间）
    self.group_bulletin_button = self.bulletin_bar.GetChildren()[1] # 群公告按钮
    if len(self.bulletin_bar.GetChildren()[2].GetChildren()) == 0:    # 如果自己是群主或管理员没设置公告就会有这个
        self.visible_group_bulletin = None  # 群公告为空
    else:   # 调用群公告解析
        self.visible_group_bulletin = self.bulletin_split(self.bulletin_bar.GetChildren()[2]) # 可见的群公告
"""群成员框(group_member_box)[文本控件(群聊成员人数)、群成员搜索、群成员列表]"""
if self.group_or_friend == "群聊":
    group_or_friend_index = 1   # 群成员位置下表
    if len(self.main_chat_win.GetChildren()[1].GetChildren()[2].GetChildren()[0].GetChildren()) == 4:   # 没有公告栏存在控件位置影响
        group_or_friend_index = 0   # 如果没有控件就是从0开始的下标
    # 2个组里面->组3->组1->组1->组2(直接文本控件(群聊成员人数))
    self.group_member_count = self.main_chat_win.GetChildren()[1].GetChildren()[2].GetChildren()[0].GetChildren()[group_or_friend_index]    # 群聊成员人数
    # 2个组里面->组3->组1->组1->组3(群搜索按钮)
    # 2个组里面->组3->组1->组1->组4->组->组2(群成员搜索输入框("编辑"EditControl))
    self.group_member_search = self.main_chat_win.GetChildren()[1].GetChildren()[2].GetChildren()[0].GetChildren()[group_or_friend_index + 1]
    self.group_member_search_input_box= self.main_chat_win.GetChildren()[1].GetChildren()[2].GetChildren()[0].GetChildren()[group_or_friend_index + 2].GetChildren()[0].GetChildren()[1]    # 群聊成员人数
    # 2个组里面->组3->组1->组1->组5->"成员列表"(一堆子组(记录群员和职称，如果是群友就没有称呼))
    self.group_member_list = self.main_chat_win.GetChildren()[1].GetChildren()[2].GetChildren()[0].GetChildren()[group_or_friend_index + 3].GetChildren()[0]
"""-----------------------------------------消息监听相关-----------------------------------------"""
self.message_data_directory = None   # 监听数据存放的目录
self.message_data_txt = None    # 监听的文本数据存放路径
```