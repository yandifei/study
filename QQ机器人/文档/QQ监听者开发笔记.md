### 1. 初始化流程
1. 判断聊天窗口是否存在，检验聊天窗口是否真实
2. 遍历根窗口的子窗口的Name是否存在给定聊天窗口的QQ群名或QQ好友名，在此窗口上深度遍历找到群QQ群名或QQ好友名二次确认是否符合要求(通过控件结构确保绑定的聊天窗口不是别的窗口)
3. 获取聊天窗口的各个控件对象、包括属性、方便以后直接对窗口进行操作而不用再次遍历

问题处理:
1. 多个QQ对同一个群或同一个好友进行监听时该如何处理被监听者名字相同的问题(我只提供群聊名称的输入，简化流程给用户)。利用同一个QQ窗口的进程ID一致判断不同QQ监听
2. 窗口句柄判断不同的窗口、窗口进程判断窗口属于哪个QQ
3. 后台能找到窗口和进程但是少了关键的文档

如果创建的是QQMessageMonitor这个对象就自动创建qq群聊或qq好友的对象，自动完成向上转型的操作

发现有2相同名字的窗口直接报错，如果要强制绑定就改名或提供句柄

可以通过类名和标题区分QQ聊天窗口和QQ本体

语音通话我没给权限提示我给权限，有这个窗口存在，后续封装得注意
语音按钮按钮也是

如果点击了群搜索后点击qq窗口以外的控件再次使用搜索控件就会发生溢出

好友聊天窗口和群聊的标题栏(title_bar)即窗口控制按钮一致

群聊窗口比好友窗口少了公告栏、群成员框

编辑工具栏如果是q群有可能少一个控件，qq机器人指令这个控件

在包目录下创建一个文件夹，文件夹用监听者的名字取名（但是目录不能存在特殊字符，如果超过一定字符或许有win自生bug蓝屏）
这个文件夹会创建一个以监听窗口（需要对特殊字符进行改变）\ / : * ? " < > |

公告会有所不同，有的群没有公告
如果公告里有图片解析方式又会不同了
1.群公告没有2.群公告要填写3.群公告有图片4.群公告有链接
公告只能是图片和文本（文本的链接可以被解析）
三层遍历
```python
def bulletin_split(obj):
    """公告文本解析（2层）可以判断该是否有公告消息，但是必须存在公告这个控件（群主可以不写公告但会有这个框）
    参数:obj:公告对象
    """
    # 无、1层、2层（链接）
    bulletin_message = ""   # 信息存储
    if len(obj.GetChildren()) != 0:
        for i in obj.GetChildren():
            if len(i.GetChildren()) != 0:   # 存在子控件需要深度查找
                for j in i.GetChildren():
                    if j.LocalizedControlType == "文本":
                        bulletin_message += j.Name + " " # 添加文本
            elif i.LocalizedControlType == "文本":    # 没有子控件
                bulletin_message += i.Name + " " # 添加文本
    return bulletin_message
```

# 消息监控
考虑到内存十分宝贵，如果消息够多对内存占用就太大了
列表的形式记录消息条数，元素是字符串或对象
qq的消息本质上可以分为2种，文本为主体、文件(图片、pdf、程序等非文本)。一条消息列表可由文本就和文件复合构成
## 1. ***分布式考虑***
单个账号对多个窗口进行监听
多个账号对单个窗口进行监听
多账号对多窗口进行监听
如果还是把消息放在内存那就完了，内存压力一定会很大
这里我就采用程序局部性原理(正态分布)
1. 空间局部性:把当前能监测到的数据放入内存，因为是当前必须用到的，即为当前能监听到的消息或需要进行处理反馈的消息，如设置的指令消息
2. 时间局部性:当前消息一般都是活跃消息，对活跃或必要性消息进行监控(有人@我或我指定某种消息为必要监听消息)。
3. 如果每监测到新的消息就写入txt会导致cpu调度繁忙，监听多个窗口会加大cpu的压力。缺点是txt不能立即实时记录最新的消息，如果突然断电会导致记录有较大的缺失

原理简说：消息记录保存类似于word，写好后一定记得保存，不然下次打开就白写。消息记录保存就是每隔一小段时间或达到相应条件就会保存一次，这就更写论文怕断电白写每隔一段时间ctrl+s保存一样，因为你不能每写一个字就保存一下，那不累死了。

***最终方案***
1. 默认消息监测到一定程度才一次性写入并在内存进行销毁（存在缓存区）。
2. 读取到有新的消息就写入

可以传入参数选择实时写入还是默认的方式写入

## 消息分割
可以通过`AutomationId`区分是不是同一个控件，判断是不是同一个控件，用来判断消息是不是更新了，在消息列表的组里面撤回的消息后不会影响`AutomationId`属性的改变

消息组合体3个组大多数为文件

时间会嵌入一个消息控件里面

最新的消息是在最后一个控件里面也就是最后的一个下表里面

自己收藏的表情无论是动态还是ss静态都被列为`"图片"图像`

对比获得的消息列表，排除没有用重复的消息，控件ID监测

消息结构:  时间 发送者 消息体

调用一次消息监听函数就更新属性
```python
self.messages_count = None  # 记录消息数属性(调用消息监控会更新)
self.AutomationId_list = None   # 记录获得消息控件的所有ID(调用消息监控会更新)
self.message_list = None  # 设置一个列表接收消息
```

致命缺点就是不能精准记录qq消息发送的时间,只能记录监控的时间。初次监控后消息会结合当前程序的时间被录入列表里面但是并不能代表这个结合的时间就是qq原来真实的时间
比如：一条消息是早上9：00发的，但是监测是按当前时间记录的，也就是只有在监控过程中时间才是精准的(约等于qq消息发送的时间)，初次调用截获消息的时间记录可能无效(最高有17条消息记录的时间无效)
后续优化可以处理`pass`

如果没有任何消息，那消息列表是否还存在控件，初始化的时候是否会造成下表溢出导致程序终止？

最开始的思路是节约时间和空间复杂度，只对新的消息进行遍历，不对部分旧的消息也进行遍历。
少了遍历的次数，时间节约了，列表也不用放入其他消息体节约空间

存在未知bug，消息体无法清空
## 文件监听
**QQ给的可选的保存位置**
将接收的文件保存到:`B:\QQ聊天文件资料\Tencent`
聊天消息默认保存到:`B:\QQ聊天文件资料\聊天文件`
**文件分析**
目录:`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Thumb`
在这个目录下会记录聊天信息中产生的图片缩略图，如果是多窗口所有图片缩略图都是汇总到这个目录下，即使把这个目录的说有图片缩略图删除了，只要回到相应的聊天窗口也能恢复图片缩略图。猜测聊天中对方发送的图片缩略图信息是保存在服务器中，我这里本地删除后回到对应的聊天记录又会加载保存到这个目录下。
***如果是别人发送的图片会产生2个图片，一个是略所图，一个是原图。如果我在qq中加载后会把原图放到Ori目录下***
目录:`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Ori`
这个是没经过压缩的原始图片文件路径，自己发送的图片或自己手动点开别人的图片加载后都会保存到这里
如果是自己发送的图片会在`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Ori`和`默认保存位置\qq账号\nt_qq\nt_data\Pic\当前年份和月份\Thumb`保存，Ori目录保存的是原文件（日期时间都没有改），Thumb保存的是压缩后的图片
表情包存放目录:`默认保存位置\qq账号\nt_qq\nt_data\Emoji\emoji-recv\当前年份和月份\Ori`
表情包压缩存放目录:`默认保存位置\qq账号\nt_qq\nt_data\Emoji\emoji-recv\当前年份和月份\Thumb`



数据形式
文本
图片
链接（不是文本展示的链接）
gif收藏表情
png收藏表情
qq自带动态表情
png图片文件
pdf文件
ppt文件
txt文件
MP4视频文件




**数据获取合法性**
脚本是通过读取控件元素获取文本消息的，图片消息是查看本地磁盘目录的，并未存在破解数据库、抓包破解的相关操作。事实上web层面上数据读取和数据操作速度更快也更好，但是qq没有提供api给编程者，只有QQ Bot的API（这也使得不能一个exe即可布置好QQ Bot）。


## BUG
```python
message_child = self.message_list_box.GetChildren()  # 这里多一个变量是为了2次遍历相同的控件
        for message_control in message_child    :# 优先遍历控件id动态更改属性
            self.AutomationId_list.append(message_control.AutomationId)  # 放置控件id
        for message_control in message_child:   # 以下标的形式遍历(方便后续处理)
            try:
                message_control = message_control.GetChildren()[0]  # 进入组控件里面（所有都单个消息控件都得进入）
                pass  # IndexError: list index out of range  提示我下标溢出
            except():
                print(len(message_control.GetChildren()))   # 打控件的子孩子数
                raise ValueError("这里会提示下标溢出，可能没有监测到控件")
```
下标溢出但是不知道为什么，亲手触发了一次，但是第二次无法触发了
拍一拍和qq控件分享无法解析
计入群聊无法解析
pass
如果速度太快会导致无法监听撤回消息
0.5秒推荐

```python
# get_messages方法里面
try:    # 估计有些消息体确实没有子孩子，或者突然过时了(实际猜测是最新的消息被顶掉了，导致控件为空)
    message_control = message_control.GetChildren()[0]  # 进入组控件里面（所有都单个消息控件都得进入）
    pass  # IndexError: list index out of range  提示我下标溢出
except IndexError as e:  # 显式捕获IndexError
    print(f"下标溢出：无法获取子控件，原始错误：{e}")
    print(f"子孩子控件数:{len(message_control.GetChildren())}")   # 打控件的子孩子数
    continue # 跳过这次控件访问
```

***实践证明我加了try后信息的收集没有受到影响，结论就是消息更新太快导致部分子控件获取失败（即为下标溢出）***。解决方案其实也和优化相关，遍历最新的消息控件不遍历失效的旧消息控件就可以办到不报错了也能极大减低cup内存的压力，极大提高利用率和消息遍历速度

# 全部可调用的属性
```python

"""-----------------------------------------消息监听相关-----------------------------------------"""
self.message_data_directory = None   # 监听数据存放的目录
self.message_data_txt = None    # 监听的文本数据存放路径
```

# 其他随笔
实践证明窗口不在屏幕上确实监测不动控件的变化，神奇的是即使窗口不在桌面上代码也能继续跑而不是报错停止，我没有加任何的异常处理在这个代码库里面


在跑代码的的时候发现`"\t"`后用win打开txt文本显示是不对称的，但是pycharm打开文本后展示的是对称的

对象创建时会传入创建文件夹和文本文件

实践测试如果清屏确实没有消息控件，会导致下标溢出`for message_control in self.message_list_box.GetChildren()`这个代码会出问题`.GetChildren()`不能用，它没有任何子孩子的消息控件


## 好友窗口监控
```txt
00:40:27 	雁低飞:	开始测试
00:40:39 	雁低飞:	大号电脑发1
00:40:51 	:	大号手机发1
00:41:09 	:	小号电脑发1
00:41:25 	:	小号手机发1
```
监控时期，只有用电脑发送消息才能监测到自己的名字，对方无论是手机还是电脑发送都没法监控到对方的名称，如果把窗口关闭后重新打开又有自己和好友的名称了


# **2025.4.28**
今天qq更新了，我无法对消息体进行监控了，消息体控件改变了。我需要修改源代码才行
修改完了，大概就是引用的消息体放到的数组2里面去
普通消息本来只有2个数组的，现在三个了


# 消息发送
编辑控件.SendKeys(发送内容)，这个控件可以向编辑控件发送内容，但是如果编辑控件没有光标就会导致发送的内容顺序错乱

我采用剪切板的方式，把需要发送的内容放到剪切板，通过向控件发送Ctrl+v的方式实现粘贴

***通过剪切的方式进行文本的写入还得是前台才行，后台就不行了，
但是.SendKeys()本身就是可以后台的，但是没办法确保发送顺序正确，我猜测是速度问题，他的实现类似一个一个字符录入，速度太快导致控件消息无法全部接收。***

.SendKeys(发送内容)有个致命缺点，他不是向指定控件发送文本的，如果你的光标在其他编辑上就会发送这个内容而不会往控件里面发送。

输入的顺序有办法解决了，设置焦点后停止一秒才输入内容
```python
self.edit_box.SetFocus()           # 设置焦点
sleep(1)
self.edit_box.SendKeys(content)    # 发送内容
```

突然感觉.SendKeys()好鸡肋，仅仅只是在光标后面发送字符，不是针对某个控件的，会和你现在用的进行冲突

点击发送就完全是后台的了，这一点完全不需要担心


# 发送效率
实际测试发送100条消息要 `54.836289` 秒，拿的是蓝宝的200多人的第三个群进行测试

```python
from time import perf_counter
from QQMessageMonitor import *  # 导包

qq_group_name = "鸣潮想睡觉（三）"
qq_monitor_name = "雁低飞"
chat_win1 = QQMessageMonitor(qq_group_name, qq_monitor_name)  # 会自动置顶和自动展示(最小化显示)
chat_win1.show_win()  # 展示窗口
chat_win1.top_win()  # 置顶窗口
sleep(2)
count_1 = 0
start = perf_counter()  # 最高精度计时器
while count_1 < 100:  # 少于100次时输出
    count_1 += 1
    chat_win1.send_message(f"我要撅蓝宝X{count_1}")
end = perf_counter()
print(f"耗时: {end - start:.6f} 秒")

```
这里不得不放弃模型切换的方法，因为会出现bug，改了更没改一样，真的不知道为什么
```python
"模型切换": [lambda: deepseek.switch_model(True),f"已切换至模型", "切换中途发生异常"],
function_map = {
        "测试": [lambda: test(), None, "切换中途发生异常"],
        "余额": [lambda: money_inquiry(),None,"发生异常"],
        # 特殊指令
        "兼容": [lambda: deepseek.compatible_openai(),"已经切换至兼容OpenAI的接口","切换中途发生异常"],
        "测试接口": [lambda: deepseek.use_beat(),"已切换至测试接口","切换中途发生异常"],
        "格式化": [lambda: deepseek.__init__(),"已格式化deepseek对话引擎","初始化中途发生异常"],  # 恢复最开始设置的参数（创建对象时的默认参数）
        # 对话参数调节指令
        "模型切换": [lambda: deepseek.switch_model(True),f"已切换至模型", "切换中途发生异常"],
        "V3模型": [lambda: deepseek.set_model("V3"),"已切换至V3模型", "切换中途发生异常"],
        "R1模型": [lambda: deepseek.set_model("R1"),"已切换至R1模型", "切换中途发生异常"],
        ........
    }
```