# YOLO 基准测试详解

## 一、为什么需要基准测试？

### 1. **模型优化决策支持**
- **选择最佳部署格式**：不同硬件平台支持不同格式（移动端→TFLite，边缘设备→ONNX，GPU服务器→TensorRT）
- **速度-精度权衡**：不同格式在不同硬件上的表现差异巨大
- **资源分配优化**：根据性能需求选择合适的模型大小

### 2. **实际应用场景**
```python
# 不同场景的需求不同
使用场景          优先级         示例格式
----------       ----------    ----------
实时视频分析      速度 > 精度     TensorRT/ONNX
医疗影像诊断      精度 > 速度     PyTorch/ONNX
移动端应用        大小 > 速度     TFLite/CoreML
边缘设备          能效 > 速度     OpenVINO
```

### 3. **避免部署失败**
- 提前发现不兼容问题
- 预估实际部署性能
- 选择最适合硬件和框架的格式

## 二、基准测试核心参数详解

### 参数结构分析
```python
from ultralytics.utils.benchmarks import benchmark

benchmark(
    model="yolo26n.pt",  # 模型路径
    data="coco8.yaml",   # 验证数据集
    imgsz=640,           # 图像大小
    half=False,          # 是否使用半精度
    device=0             # 运行设备
)
```

### 1. **model参数** - 待测试的模型
```python
# 支持多种输入方式
benchmark(model="yolo26n.pt")                # 单模型
benchmark(model=["yolo26n.pt", "yolo26s.pt"]) # 多模型比较
benchmark(model="yolo26n.onnx")              # 已导出的模型
benchmark(model="yolo26n.pt, yolo26n.onnx")  # 混合格式
```

### 2. **data参数** - 验证数据集
```python
benchmark(data="coco8.yaml")        # 官方示例数据集（小）
benchmark(data="coco128.yaml")      # 中等规模数据集
benchmark(data="your_dataset.yaml") # 自定义数据集

# 数据集的重要性：
# 1. 评估准确度（mAP50-95）
# 2. 测试泛化能力
# 3. 确保实际应用性能
```

### 3. **imgsz参数** - 输入图像大小
```python
benchmark(imgsz=320)    # 小尺寸，速度快，精度较低
benchmark(imgsz=640)    # 标准尺寸，平衡速度精度
benchmark(imgsz=1280)   # 大尺寸，精度高，速度慢
benchmark(imgsz=[320, 640, 1280])  # 测试多种尺寸
```

### 4. **half参数** - 半精度推理
```python
benchmark(half=False)   # 使用FP32（全精度），精度最高
benchmark(half=True)    # 使用FP16（半精度），速度快，内存小

# 支持情况：
# - GPU: 大多支持FP16
# - CPU: 通常不支持FP16加速
# - 某些硬件（如Jetson）有特殊要求
```

### 5. **device参数** - 运行设备
```python
benchmark(device="cpu")        # CPU推理
benchmark(device=0)            # GPU 0（默认）
benchmark(device=[0, 1])       # 多GPU测试
benchmark(device="cuda")       # 所有可用GPU
benchmark(device="mps")        # Apple Silicon (M1/M2/M3)
```

## 三、完整基准测试参数列表

```python
benchmark(
    # 必需参数
    model="yolo26n.pt",        # 模型路径或列表
    data="coco8.yaml",         # 数据集配置文件
    
    # 推理参数
    imgsz=640,                 # 输入图像大小
    batch=1,                   # 批处理大小
    half=False,                # FP16半精度推理
    int8=False,                # INT8量化
    device="cpu",              # 运行设备
    verbose=False,             # 是否显示详细信息
    
    # 测试控制
    n=100,                     # 每个格式的测试次数
    min_time=60,               # 最小测试时间（秒）
    amp=False,                 # 自动混合精度
    
    # 输出控制
    save_json=False,           # 保存JSON结果
    save_txt=False,            # 保存文本结果
    plots=True,                # 生成图表
    exist_ok=False,            # 允许覆盖现有结果
    
    # 特定格式参数
    trt=True,                  # 测试TensorRT
    onnx=True,                 # 测试ONNX
    tflite=True,               # 测试TFLite
    openvino=True,             # 测试OpenVINO
    coreml=True,               # 测试CoreML
    paddle=False,              # 测试PaddlePaddle
    ncnn=False,                # 测试NCNN
    
    # 硬件特定
    workspace=4,               # TensorRT工作空间大小（GB）
    calibration=False,         # 是否进行校准（INT8）
)
```

## 四、基准测试输出详解

### 1. **典型输出格式**
```
Model                   Format      Size (MB)  mAP50-95  Inference Time (ms)  FPS
----------------------  ----------  ---------  --------  -------------------  ----
yolo26n                 PyTorch     3.9        0.452     6.4                  156.2
yolo26n                 ONNX        3.9        0.450     5.8                  172.4
yolo26n                 TensorRT    3.9        0.449     3.2                  312.5
yolo26n                 OpenVINO    3.9        0.450     4.1                  243.9
yolo26n                 TFLite      4.1        0.448     12.5                 80.0
yolo26n                 CoreML      4.2        0.449     8.2                  121.9
```

### 2. **关键指标解读**
- **Size (MB)**：模型文件大小，影响存储和加载时间
- **mAP50-95**：模型准确度，值越高越好
- **Inference Time (ms)**：单张图像推理时间
- **FPS**：每秒处理帧数，实时应用关键指标

### 3. **可视化输出**
```python
benchmark(plots=True)  # 会生成以下图表：
# 1. 速度-精度曲线
# 2. 模型大小对比图
# 3. 各格式性能对比图
```

## 五、实战应用示例

### 示例1：全面基准测试
```python
from ultralytics.utils.benchmarks import benchmark
import pandas as pd

# 测试多个模型和格式
results = benchmark(
    model=["yolo26n.pt", "yolo26s.pt", "yolo26m.pt"],
    data="coco128.yaml",
    imgsz=640,
    half=True,
    device=0,
    trt=True,
    onnx=True,
    openvino=True,
    plots=True,
    save_json=True
)

# 转换为DataFrame分析
df = pd.DataFrame(results)
print("性能对比：")
print(df[['Model', 'Format', 'mAP50-95', 'FPS']])

# 找出最佳平衡点
df['Score'] = df['mAP50-95'] * df['FPS'] / df['Size (MB)']
best_model = df.loc[df['Score'].idxmax()]
print(f"\n最佳模型: {best_model['Model']} ({best_model['Format']})")
print(f"综合评分: {best_model['Score']:.2f}")
```

### 示例2：硬件选型测试
```python
def benchmark_hardware_selection():
    """测试不同硬件上的性能"""
    
    hardware_configs = [
        {"name": "RTX 4090", "device": 0, "half": True},
        {"name": "RTX 3080", "device": 0, "half": True},
        {"name": "Jetson Xavier", "device": 0, "half": True},
        {"name": "Intel i9 CPU", "device": "cpu", "half": False},
        {"name": "Apple M2", "device": "mps", "half": True}
    ]
    
    results = []
    for config in hardware_configs:
        print(f"\n测试硬件: {config['name']}")
        
        # 执行基准测试
        metrics = benchmark(
            model="yolo26n.pt",
            data="coco8.yaml",
            imgsz=640,
            half=config['half'],
            device=config['device'],
            n=50,
            verbose=False
        )
        
        results.append({
            "Hardware": config['name'],
            "Device": config['device'],
            "FPS": metrics[0]['FPS'],
            "Latency (ms)": metrics[0]['Inference Time (ms)']
        })
    
    return results

# 执行硬件测试
hardware_results = benchmark_hardware_selection()
for r in hardware_results:
    print(f"{r['Hardware']:20} | FPS: {r['FPS']:6.1f} | 延迟: {r['Latency (ms)']:5.1f}ms")
```

### 示例3：生产环境部署前测试
```python
def production_benchmark():
    """生产环境部署前的全面测试"""
    
    test_configs = [
        # 格式，精度，批大小
        ("onnx", False, 1),
        ("onnx", True, 1),
        ("tensorrt", True, 1),
        ("tensorrt", True, 8),
        ("openvino", False, 1),
        ("tflite", False, 1),
    ]
    
    results = {}
    for fmt, use_half, batch in test_configs:
        print(f"\n测试配置: {fmt}, half={use_half}, batch={batch}")
        
        try:
            # 先导出模型
            model = YOLO("yolo26n.pt")
            model.export(format=fmt, half=use_half, imgsz=640)
            
            # 基准测试
            metrics = benchmark(
                model=f"yolo26n.{fmt}",
                data="validation_dataset.yaml",
                imgsz=640,
                half=use_half,
                device=0,
                batch=batch,
                n=1000,
                min_time=30
            )
            
            results[f"{fmt}_half{use_half}_batch{batch}"] = metrics
            print(f"  FPS: {metrics[0]['FPS']:.1f}, mAP: {metrics[0]['mAP50-95']:.3f}")
            
        except Exception as e:
            print(f"  错误: {e}")
            results[f"{fmt}_half{use_half}_batch{batch}"] = None
    
    return results

# 执行生产环境测试
production_results = production_benchmark()
```

## 六、基准测试最佳实践

### 1. **测试环境准备**
```python
# 确保环境干净
import torch
print(f"PyTorch版本: {torch.__version__}")
print(f"CUDA可用: {torch.cuda.is_available()}")
print(f"CUDA版本: {torch.version.cuda}")
print(f"设备: {torch.cuda.get_device_name(0)}")
```

### 2. **测试数据选择**
```python
# 使用代表性数据集
# 小数据集：快速迭代
benchmark(data="coco8.yaml")     # 8张图片，快速测试

# 中等数据集：平衡测试
benchmark(data="coco128.yaml")   # 128张图片，可靠评估

# 真实数据集：最终验证
benchmark(data="real_world.yaml") # 实际应用数据
```

### 3. **测试流程优化**
```python
def efficient_benchmark():
    """分阶段基准测试"""
    
    # 阶段1：快速筛选
    print("阶段1：快速筛选")
    quick_results = benchmark(
        model="yolo26n.pt",
        data="coco8.yaml",
        imgsz=640,
        n=10,           # 少量测试
        min_time=10,    # 最短时间
        verbose=True
    )
    
    # 阶段2：精确评估（对候选格式）
    print("\n阶段2：精确评估")
    detailed_results = benchmark(
        model=["yolo26n.onnx", "yolo26n.engine"],
        data="coco128.yaml",
        imgsz=640,
        n=100,
        min_time=60,
        verbose=True
    )
    
    return quick_results, detailed_results
```

### 4. **结果分析与决策**
```python
def analyze_benchmark_results(results):
    """分析基准测试结果并给出建议"""
    
    print("="*60)
    print("基准测试结果分析")
    print("="*60)
    
    # 按FPS排序
    sorted_results = sorted(results, key=lambda x: x['FPS'], reverse=True)
    
    print("\n性能排名（按FPS）：")
    for i, r in enumerate(sorted_results[:5], 1):
        print(f"{i:2}. {r['Format']:10} - FPS: {r['FPS']:6.1f}, "
              f"mAP: {r['mAP50-95']:.3f}, Size: {r['Size (MB)']:.1f}MB")
    
    # 推荐逻辑
    print("\n推荐方案：")
    
    # 实时应用（FPS > 30）
    real_time = [r for r in sorted_results if r['FPS'] > 30]
    if real_time:
        best_rt = real_time[0]
        print(f"实时应用: {best_rt['Format']} (FPS: {best_rt['FPS']:.0f})")
    
    # 精度优先应用（mAP最高）
    best_accuracy = max(results, key=lambda x: x['mAP50-95'])
    print(f"精度优先: {best_accuracy['Format']} (mAP: {best_accuracy['mAP50-95']:.3f})")
    
    # 资源受限应用（大小最小）
    smallest = min(results, key=lambda x: x['Size (MB)'])
    print(f"资源受限: {smallest['Format']} (大小: {smallest['Size (MB)']:.1f}MB)")
    
    return sorted_results
```

## 七、常见问题与解决方案

### 问题1：基准测试时间太长
```python
# 解决方案：合理设置参数
benchmark(
    n=10,        # 减少测试次数
    min_time=30, # 设置最大测试时间
    trt=False,   # 跳过耗时格式
    verbose=False
)
```

### 问题2：特定格式测试失败
```python
# 解决方案：检查依赖
import subprocess

def check_dependencies():
    """检查必要的依赖"""
    deps = {
        "onnx": ["onnx", "onnxruntime"],
        "tensorrt": ["tensorrt"],
        "openvino": ["openvino"],
    }
    
    for fmt, packages in deps.items():
        print(f"\n检查 {fmt} 依赖:")
        for pkg in packages:
            try:
                __import__(pkg)
                print(f"  ✓ {pkg}")
            except ImportError:
                print(f"  ✗ {pkg} 未安装")
```

### 问题3：结果波动大
```python
# 解决方案：增加测试稳定性
benchmark(
    n=100,       # 增加测试次数
    min_time=60, # 延长测试时间
    warmup=10,   # 添加预热（如果支持）
    device="cpu" # CPU结果更稳定
)
```

## 八、总结

### 基准测试的核心价值：
1. **科学决策**：基于数据选择最佳模型和格式
2. **性能预估**：提前了解部署后的性能表现
3. **问题发现**：识别兼容性和性能瓶颈
4. **资源优化**：平衡速度、精度和资源消耗

### 关键建议：
- **分阶段测试**：先快速筛选，再精确评估
- **真实数据**：使用接近实际应用的数据集
- **环境一致**：测试环境尽量接近部署环境
- **全面评估**：考虑速度、精度、大小、兼容性
- **文档记录**：保存测试结果供未来参考

基准测试不是一次性的任务，而是**持续优化的过程**。随着硬件升级、软件更新、需求变化，定期重新测试可以确保始终使用最优方案。