https://fastapi.tiangolo.com/tutorial/body/
# 请求正文
当您需要从客户端（例如浏览器）向您的 API 发送数据时，您需要将其作为请求正文发送。
请求体是客户端发送给 API 的数据。响应体是 API 发送给客户端的数据。
你的 API 几乎总是需要发送响应体。但客户端并非总是需要发送请求体，有时它们可​​能只请求一个路径（可能带有一些查询参数），而不会发送请求体。
要声明请求体，您可以使用pydantic具备所有功能和优势的模型。

**要发送数据，您应该使用以下之一：（POST更常用）PUT，DELETE或PATCH。
规范中对请求体发送行为GET进行了未定义规定，但 FastAPI 支持这种做法，不过仅限于非常复杂/极端的用例。 
由于不建议这样做，使用 Swagger UI 的交互式文档不会显示正文的文档GET，并且中间的代理可能不支持它。**

# 导入 Pydantic 的BaseModel
首先，您需要BaseModel从以下位置导入pydantic
```python
from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item
```

# 创建数据模型
然后，您可以将数据模型声明为继承自 的类BaseModel。
所有属性均使用标准 Python 类型：
```python
from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    return item
```
与声明查询参数时相同，当模型属性具有默认值时，则该属性不是必需的；否则，该属性是必需的。
可以使用 `@Optional`None将其设置为可选。
例如，上面的模型声明了一个 JSON " object"（或 Python dict）如下
```json
{
    "name": "Foo",
    "description": "An optional description",
    "price": 45.2,
    "tax": 3.5
}
```
由于 `and`description和`or`tax是可选的（默认值为 `false` None），因此以下 JSON " object" 也是有效的：
```json
{
    "name": "Foo",
    "price": 45.2
}
```

# 结果
仅需这条 Python 类型声明，FastAPI即可：

以 JSON 格式读取请求正文。
- （如果需要）转换相应的类型。
- 验证数据。
  - 如果数据无效，它会返回一个清晰明确的错误信息，准确指出错误数据的位置和内容。
- 将接收到的数据以参数的形式提供给您item。
  - 由于您在函数中将其声明为类型Item，因此您还将获得所有属性及其类型的编辑器支持（自动完成等）。
- 产生JSON 模式您可以为模型定义，如果对您的项目有意义，您也可以在任何其他地方使用它们。
- 这些模式将成为生成的 OpenAPI 模式的一部分，并被自动文档UI使用。

# 自动文档
模型的 JSON Schema 将成为 OpenAPI 生成的 schema 的一部分，并显示在交互式 API 文档中：
https://fastapi.tiangolo.com/img/tutorial/body/image01.png
此外，API 文档中每个需要用到它们的路径操作也会用到它们：
https://fastapi.tiangolo.com/img/tutorial/body/image02.png

# 编辑支持
dict在编辑器中，函数内部会显示类型提示和自动完成功能（如果您收到的是一个 Pydantic 模型而不是一个 Pydantic 模型，则不会出现这种情况）：
https://fastapi.tiangolo.com/img/tutorial/body/image03.png
它还会针对错误类型操作进行错误检查：
https://fastapi.tiangolo.com/img/tutorial/body/image04.png
这并非偶然，整个框架都是围绕这个设计构建的。
在设计阶段，也就是实施之前，它经过了彻底的测试，以确保它能与所有编辑器兼容。
为了支持这一点，Pydantic 本身也进行了一些更改。
之前的屏幕截图是用Visual Studio Code。
但您将获得同样的编辑器支持PyCharm以及大多数其他Python编辑器：
https://fastapi.tiangolo.com/img/tutorial/body/image05.png

如果你使用PyCharm作为你的编辑器，你可以使用Pydantic PyCharm 插件。
它改进了编辑器对 Pydantic 模型的支持，具体包括：
自动补全
类型检查
重构
搜索
检查

# 使用模型
在函数内部，您可以直接访问模型对象的所有属性：
```python
from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.post("/items/")
async def create_item(item: Item):
    item_dict = item.model_dump()
    if item.tax is not None:
        price_with_tax = item.price + item.tax
        item_dict.update({"price_with_tax": price_with_tax})
    return item_dict
```

# 请求体 + 路径参数
您可以同时声明路径参数和请求正文。

FastAPI会识别出与路径参数匹配的函数参数应该从路径中获取，而声明为 Pydantic 模型的函数参数应该从请求正文中获取。
```python
from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    return {"item_id": item_id, **item.model_dump()}
```

# 请求体 + 路径 + 查询参数
您还可以同时声明请求体、路径和查询参数。
FastAPI将识别它们中的每一个，并从正确的位置获取数据。
```python
from fastapi import FastAPI
from pydantic import BaseModel


class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None


app = FastAPI()


@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, q: str | None = None):
    result = {"item_id": item_id, **item.model_dump()}
    if q:
        result.update({"q": q})
    return result
```

函数参数的识别方式如下：
如果该参数也在路径中声明，则它将被用作路径参数。
如果参数是单数类型（例如int，，，，等） float，则会被解释为查询参数。strbool
如果参数被声明为Pydantic 模型类型，则会被解释为请求体。

FastAPI 会知道q由于默认值，因此不需要该值= None。
FastAPI 不使用str | None(Python 3.10+) 或(Python 3.9+)Union中的值来确定该值是否为必填项，而是通过其默认值来判断该值是否为必填项。Union[str, None]= None
但是，添加类型注释可以让编辑器提供更好的支持并检测错误。


如果您不想使用 Pydantic 模型，也可以使用Body参数。请参阅文档:
https://fastapi.tiangolo.com/tutorial/body-multiple-params/#singular-values-in-body